# Base Concepts
**ECS** - это архитектурный паттерн реализующий принципы 
*Data-Oriented Design*(DOD) и расшифровывающийся как 
Entity-Component-System

**Entity** - некий уникальный ключ однозначно идентифицирующий
сущность.

**Component** - содержит непосредственные данные, хотя
это не обязательно. Компонент может маркировать сущности
и тогда его обычно называют тегом. Компоненты не содержат
никакой логики - только данные.

**System** - непосредственно логика. Каждая система берёт
необходимые ей данные и обрабатывает их, меняя или создавая
новые данные или новые сущности.

Про данный паттерн написано множество статей, которые легко
можно найти в интернете. Более детально про DOD и ECS можно
прочитать по ссылке ниже

[DOD Book](https://www.dataorienteddesign.com/dodbook/)

***
# Getting Started
### Modules
В GoldEcs все системы живут внутри модулей. Модуль - это класс
наследующийся от `EcsModule`. Если модуль помечен
аттрибутом `EcsGlobalModule`, то он автоматически
запустится на старте. Обычно в вашей игре будет как минимум
один глобальный модуль.
<br>
<h5>Creating global module</h5>

1. Создайте класс модуля
2. Отнаследуйтесь от `EcsModule`
3. Укажите у класса аттрибут `EcsGlobalModule`
4. Переопределите метод `Setup()` - данный метод
запускается при старте модуля (он также может быть 
асинхронным)
5. Внутри метода `Setup()` вы можете проводить инициализацию 
необходимых ресурсов (например, префабов) и различных вспомогательных
классов
6. Если всё сделано верно, то при запуске **любой** сцены данный
модуль будет активирован и вызовется `Setup()`

<h3>Systems</h3>
Одна из ключевых фич GoldEcs заключается в отсутствии необходимости явно
создавать системы. Достаточно создать класс системы, указать у него аттрибут
`EcsSystem(<тип модуля>)` и реализовать один из интерфейсов систем.
<h5>Типы систем:</h5>
- `IEcsPreInitSystem` - вызывается в самом начале активации модуля,
хорошо подходит для создания сущностей
- `IEcsInitSystem` - вызывается в момент активации модуля
после `IEcsPreInitSystem`
- `IEcsRunSystem` - для логики которая должна отрабатывать 
каждый апдейт (`Update()`)
- `IEcsRunPhysicSystem` - вызывается в момент
обновления физики (`FixedUpdate()`)
- `IEcsRunLateSystem` - вызывается в конце кадра 
(`LateUpdate()`), хорошо подходит для проверки 
однокадровых сущностей
- `IEcsDestroySystem` - вызывается в момент 
выключения модуля
- `IEcsPostDestroySystem` - вызывается в самом конце
выключения модуля, хорошо подходит для удаления сущностей

### System's order
В ряде случаев может потребоваться задать порядок систем (например, 
чтобы ввод пользователя обрабатывался в самом начале кадра). Для этого
можно переопределить метод `GetSystemsOrder()`. Этот метод
должен воозвращать словарь, где ключом является тип системы, а 
значением - целое число. По умолчанию все системы имеют нулевой порядок.
Сортировка происходит по возрастанию.

# Into deep
### Modules system
Модули позволяют удобно группировать различный функционал. Для активации
модуля используется метод `EcsWorld.ActivateModule<тип модуля>()`. Аналогично
для деактивации используется `EcsWorld.DeactivateModule<тип модуля>()`. 

**Важно!** При деактивации модуля все его системы уничтожаются, но сущности
остаются - их нужно удалять самостоятельно. Это можно делать в соответствующих системах.
Другой способ - создать систему с реализацией `IEcsPostDestroySystem` и 
компонент-тег, по которому будут фильтроваться сущности, которые нужно удалить.
Вы можете реализовать любой удобный для вас способ удаления сущностей.

### DI in systems
Внутри систем можно получать доступ к различным объектам: миру, фильтрам,
сервисам и отображениям. Ниже подробности про каждый тип объектов и как внедрить их в ваши 
системы.

#### The World
Все данные в ECS живут в так называемом "мире", который представляет объект
типа `EcsWorld`. Чтобы получить к нему доступ, достаточно добавить приватное
поле данного типа в системе и фреймворк автоматически внедрит его в систему
с помощью рефлексии. Подробнее про сам `EcsWorld` читайте в соответствующем разделе.

#### Filters
Чтобы получить доступ к сущностям, в системах используются фильтры. Они 
внедряются также автоматически, вам лишь нужно создать поле с типом
`EcsFilter<T>` где T - компонент. Фильтры могут содержать больше одного компонента 
или исключать сущности с каким-либо компонентом. Более подробно о типах
фильтров можно прочитать в документации по LeoECS (но не LeoECS Lite).

#### Services and Views
Порой вам нужна похожая логика в разных системах. Или же вы можете захотеть
вынести сложную логику в отдельный класс, но не хотите делать его статическим.
В этих случаях можно воспользоваться отдельными классами. Важно только, чтобы
они также не содержали данных. 

Такие классы не внедряются автоматически. Вместо этого они должны быть 
созданы вручную внутри соответствующего модуля:
1. создайте объект внутри модуля (например, в `Setup()`)
2. переопределите метод `GetDependencies()`, он должен вернуть словарь
вида Тип объекта - Объект
3. после этого вы можете получить доступ к этому объекту в любой системе
Обратите внимание, что, поскольку сервис не содержит данных, его можно 
безопасно использовать в различных системах.

Аналогичным образом можно внедрять классы наследники `MonoBehaviour`, 
для управления отображением. 
1. создайте или загрузите в память необходимые префабы в модуле в 
методе `Setup()`. Обратите внимание, что вы можете пометить его как
асинхронный и использовать `Addressables` для загрузки и создания объектов
2. получите необходимые объекты. Несколько хороших способов приведено в 
разделе Best Practice ниже
3. возвращайте полученные объекты в методе `GetDependencies()`

##### Global module and submodules
Все зависимости, которые имеются в модулях помеченных как глобальные, 
внедряются также и в любые другие модули.

В крупном проекте может возникнуть потребность в иерархии модулей. При 
системы в "дочернем" модуле могут требовать доступа к тем же зависимостям,
что и в родительском. Специально для таких случаев при активации модуля
можно указать в качестве параметра тип родительского модуля.